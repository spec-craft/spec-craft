# SpecCraft Phase 1: Core CLI (MVP) Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build the minimum viable SpecCraft CLI with basic workflow execution capability.

**Architecture:** TypeScript CLI using Commander.js for command parsing, yaml/ts for workflow configuration parsing, Mustache for template rendering. The CLI operates on marketplace directories containing workflow definitions.

**Tech Stack:** TypeScript, Node.js 18+, Commander.js, yaml, mustache, fs-extra, vitest

---

## Task 1: Project Setup

**Files:**
- Create: `package.json`
- Create: `tsconfig.json`
- Create: `vitest.config.ts`
- Create: `.gitignore` (update)

**Step 1: Create package.json**

```json
{
  "name": "@speccraft/cli",
  "version": "0.1.0",
  "description": "Spec Creator - CLI tool for spec-driven workflows",
  "type": "module",
  "bin": {
    "craft": "./dist/bin/craft.js"
  },
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "test": "vitest run",
    "test:watch": "vitest",
    "lint": "eslint src",
    "typecheck": "tsc --noEmit"
  },
  "keywords": [
    "spec",
    "workflow",
    "cli",
    "ai",
    "agent"
  ],
  "author": "",
  "license": "MIT",
  "engines": {
    "node": ">=18.0.0"
  },
  "dependencies": {
    "commander": "^12.0.0",
    "fs-extra": "^11.2.0",
    "mustache": "^4.2.0",
    "yaml": "^2.3.4"
  },
  "devDependencies": {
    "@types/fs-extra": "^11.0.4",
    "@types/mustache": "^4.2.5",
    "@types/node": "^20.11.0",
    "typescript": "^5.3.3",
    "vitest": "^1.2.0"
  }
}
```

**Step 2: Create tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

**Step 3: Create vitest.config.ts**

```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['src/**/*.test.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['src/**/*.ts'],
      exclude: ['src/**/*.test.ts', 'src/bin/**']
    }
  }
});
```

**Step 4: Run npm install**

Run: `npm install`
Expected: Dependencies installed successfully

**Step 5: Commit**

```bash
git add package.json package-lock.json tsconfig.json vitest.config.ts
git commit -m "chore: initial project setup with TypeScript and vitest

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>"
```

---

## Task 2: CLI Entry Point

**Files:**
- Create: `src/bin/craft.ts`
- Create: `src/index.ts`
- Create: `src/cli.ts`

**Step 1: Write the failing test for CLI entry**

```typescript
// src/cli.test.ts
import { describe, it, expect } from 'vitest';
import { parseArgs } from './cli.js';

describe('CLI', () => {
  it('should parse init command', () => {
    const result = parseArgs(['node', 'craft', 'init', 'my-workflows']);
    expect(result.command).toBe('init');
    expect(result.args).toEqual(['my-workflows']);
  });

  it('should parse run command with workflow and subcommand', () => {
    const result = parseArgs(['node', 'craft', 'run', 'brainstorm', 'init', 'my-topic']);
    expect(result.command).toBe('run');
    expect(result.workflow).toBe('brainstorm');
    expect(result.subcommand).toBe('init');
    expect(result.args).toEqual(['my-topic']);
  });

  it('should show help when no args', () => {
    const result = parseArgs(['node', 'craft']);
    expect(result.command).toBe('help');
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test -- src/cli.test.ts`
Expected: FAIL - parseArgs not defined

**Step 3: Write minimal implementation**

```typescript
// src/cli.ts
import { Command } from 'commander';

export interface ParsedArgs {
  command: string;
  workflow?: string;
  subcommand?: string;
  args: string[];
  options: Record<string, unknown>;
}

export function parseArgs(argv: string[]): ParsedArgs {
  const program = new Command();

  program
    .name('craft')
    .description('Spec Creator - CLI tool for spec-driven workflows')
    .version('0.1.0');

  program
    .command('init <name>')
    .description('Create a new marketplace')
    .action(() => {});

  program
    .command('copy <template>')
    .description('Copy a workflow from template library')
    .action(() => {});

  program
    .command('run <workflow> <command>')
    .description('Run a workflow command')
    .option('-f, --force', 'Force re-execution')
    .option('--no-auto', 'Skip automatic dependency execution')
    .action(() => {});

  program
    .command('list')
    .description('List all workflows')
    .action(() => {});

  // Parse
  try {
    program.parse(argv);
  } catch {
    // Handle parse errors gracefully
  }

  const args = argv.slice(2);

  if (args.length === 0) {
    return { command: 'help', args: [], options: {} };
  }

  const command = args[0];

  if (command === 'run') {
    return {
      command: 'run',
      workflow: args[1],
      subcommand: args[2],
      args: args.slice(3),
      options: {}
    };
  }

  return {
    command,
    args: args.slice(1),
    options: {}
  };
}
```

**Step 4: Run test to verify it passes**

Run: `npm test -- src/cli.test.ts`
Expected: PASS

**Step 5: Create bin entry point**

```typescript
// src/bin/craft.ts
#!/usr/bin/env node
import { program } from 'commander';
import { initCommand } from '../commands/init.js';
import { copyCommand } from '../commands/copy.js';
import { runCommand } from '../commands/run.js';

program
  .name('craft')
  .description('Spec Creator - CLI tool for spec-driven workflows')
  .version('0.1.0');

program.addCommand(initCommand);
program.addCommand(copyCommand);
program.addCommand(runCommand);

program.parse();
```

**Step 6: Create main export**

```typescript
// src/index.ts
export { parseArgs, type ParsedArgs } from './cli.js';
export { WorkflowLoader } from './core/WorkflowLoader.js';
export { CommandExecutor } from './core/CommandExecutor.js';
export { StateManager } from './core/StateManager.js';
export { TemplateRenderer } from './core/TemplateRenderer.js';
```

**Step 7: Commit**

```bash
git add src/bin/craft.ts src/index.ts src/cli.ts src/cli.test.ts
git commit -m "feat: add CLI entry point with commander

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>"
```

---

## Task 3: Workflow Loader

**Files:**
- Create: `src/core/WorkflowLoader.ts`
- Create: `src/types/workflow.ts`

**Step 1: Write type definitions**

```typescript
// src/types/workflow.ts
export interface WorkflowVariable {
  type: 'string' | 'select' | 'boolean' | 'computed';
  required?: boolean;
  description?: string;
  prompt?: string;
  options?: string[];
  default?: string | boolean;
  formula?: string;
}

export interface WorkflowCommand {
  description: string;
  type?: 'template' | 'execution' | 'query' | 'interactive';
  template?: string;
  output?: string;
  dependsOn?: string[];
  autoRunDeps?: boolean;
}

export interface WorkflowDefinition {
  name: string;
  version: string;
  description?: string;
  variables?: Record<string, WorkflowVariable>;
  commands: Record<string, WorkflowCommand>;
}

export interface LoadedWorkflow {
  path: string;
  definition: WorkflowDefinition;
}
```

**Step 2: Write the failing test**

```typescript
// src/core/WorkflowLoader.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, writeFile, rm } from 'fs/promises';
import { join } from 'path';
import { WorkflowLoader } from './WorkflowLoader.js';

describe('WorkflowLoader', () => {
  const testDir = join(process.cwd(), '.test-workflows');

  beforeEach(async () => {
    await mkdir(testDir, { recursive: true });
  });

  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
  });

  it('should load a valid workflow.yaml', async () => {
    const workflowDir = join(testDir, 'test-workflow');
    await mkdir(workflowDir);

    const workflowYaml = `
name: test-workflow
version: 1.0.0
description: A test workflow

variables:
  topic:
    type: string
    required: true
    description: Topic name

commands:
  init:
    description: Initialize
    template: templates/init.md
    output: "specs/{{topic}}/init.md"
`;

    await writeFile(join(workflowDir, 'workflow.yaml'), workflowYaml);

    const loader = new WorkflowLoader();
    const workflow = await loader.load(workflowDir);

    expect(workflow.definition.name).toBe('test-workflow');
    expect(workflow.definition.version).toBe('1.0.0');
    expect(workflow.definition.variables?.topic.type).toBe('string');
    expect(workflow.definition.commands.init.description).toBe('Initialize');
  });

  it('should throw error for invalid workflow.yaml', async () => {
    const workflowDir = join(testDir, 'invalid-workflow');
    await mkdir(workflowDir);

    // Missing required 'name' field
    const workflowYaml = `
version: 1.0.0
commands:
  init:
    description: Initialize
`;

    await writeFile(join(workflowDir, 'workflow.yaml'), workflowYaml);

    const loader = new WorkflowLoader();
    await expect(loader.load(workflowDir)).rejects.toThrow();
  });

  it('should throw error if workflow.yaml not found', async () => {
    const loader = new WorkflowLoader();
    await expect(loader.load('/nonexistent/path')).rejects.toThrow('not found');
  });
});
```

**Step 3: Run test to verify it fails**

Run: `npm test -- src/core/WorkflowLoader.test.ts`
Expected: FAIL - WorkflowLoader not defined

**Step 4: Write minimal implementation**

```typescript
// src/core/WorkflowLoader.ts
import { readFile, access } from 'fs/promises';
import { join } from 'path';
import { parse } from 'yaml';
import type { WorkflowDefinition, LoadedWorkflow } from '../types/workflow.js';

export class WorkflowLoader {
  async load(workflowPath: string): Promise<LoadedWorkflow> {
    const yamlPath = join(workflowPath, 'workflow.yaml');

    // Check if file exists
    try {
      await access(yamlPath);
    } catch {
      throw new Error(`workflow.yaml not found at ${workflowPath}`);
    }

    // Read and parse
    const content = await readFile(yamlPath, 'utf-8');
    const definition = parse(content) as WorkflowDefinition;

    // Validate required fields
    this.validate(definition);

    return {
      path: workflowPath,
      definition
    };
  }

  private validate(definition: WorkflowDefinition): void {
    if (!definition.name) {
      throw new Error('workflow.yaml must have a "name" field');
    }
    if (!definition.version) {
      throw new Error('workflow.yaml must have a "version" field');
    }
    if (!definition.commands || Object.keys(definition.commands).length === 0) {
      throw new Error('workflow.yaml must have at least one command');
    }
  }
}
```

**Step 5: Run test to verify it passes**

Run: `npm test -- src/core/WorkflowLoader.test.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add src/core/WorkflowLoader.ts src/core/WorkflowLoader.test.ts src/types/workflow.ts
git commit -m "feat: add WorkflowLoader for parsing workflow.yaml

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>"
```

---

## Task 4: Template Renderer

**Files:**
- Create: `src/core/TemplateRenderer.ts`

**Step 1: Write the failing test**

```typescript
// src/core/TemplateRenderer.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, writeFile, rm } from 'fs/promises';
import { join } from 'path';
import { TemplateRenderer } from './TemplateRenderer.js';

describe('TemplateRenderer', () => {
  const testDir = join(process.cwd(), '.test-templates');
  let renderer: TemplateRenderer;

  beforeEach(async () => {
    await mkdir(testDir, { recursive: true });
    renderer = new TemplateRenderer();
  });

  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
  });

  it('should render template with variables', async () => {
    const templatePath = join(testDir, 'test.md');
    await writeFile(templatePath, '# {{title}}\n\nHello, {{name}}!');

    const result = await renderer.render(templatePath, {
      title: 'My Document',
      name: 'World'
    });

    expect(result).toBe('# My Document\n\nHello, World!');
  });

  it('should handle nested variable paths', async () => {
    const templatePath = join(testDir, 'nested.md');
    await writeFile(templatePath, 'Output: {{outputDir}}/spec.md');

    const result = await renderer.render(templatePath, {
      outputDir: 'specs/my-feature'
    });

    expect(result).toBe('Output: specs/my-feature/spec.md');
  });

  it('should handle missing variables gracefully', async () => {
    const templatePath = join(testDir, 'missing.md');
    await writeFile(templatePath, 'Value: {{missing}}');

    const result = await renderer.render(templatePath, {});

    // Missing variables should be empty string
    expect(result).toBe('Value: ');
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test -- src/core/TemplateRenderer.test.ts`
Expected: FAIL - TemplateRenderer not defined

**Step 3: Write minimal implementation**

```typescript
// src/core/TemplateRenderer.ts
import { readFile } from 'fs/promises';
import Mustache from 'mustache';

export interface TemplateVariables {
  [key: string]: string | number | boolean | TemplateVariables;
}

export class TemplateRenderer {
  async render(templatePath: string, variables: TemplateVariables): Promise<string> {
    const template = await readFile(templatePath, 'utf-8');
    return Mustache.render(template, variables);
  }

  renderString(template: string, variables: TemplateVariables): string {
    return Mustache.render(template, variables);
  }
}
```

**Step 4: Run test to verify it passes**

Run: `npm test -- src/core/TemplateRenderer.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/core/TemplateRenderer.ts src/core/TemplateRenderer.test.ts
git commit -m "feat: add TemplateRenderer using Mustache

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>"
```

---

## Task 5: State Manager

**Files:**
- Create: `src/core/StateManager.ts`
- Create: `src/types/state.ts`

**Step 1: Write type definitions**

```typescript
// src/types/state.ts
export type CommandStatus = 'pending' | 'in_progress' | 'completed' | 'needs-update' | 'failed' | 'skipped';

export interface CommandState {
  status: CommandStatus;
  startedAt?: string;
  completedAt?: string;
  output?: string;
  invalidatedBy?: string;
  invalidatedAt?: string;
  previousStatus?: CommandStatus;
}

export interface WorkflowInstanceState {
  instance: string;
  workflow: string;
  createdAt: string;
  updatedAt: string;
  variables: Record<string, string | number | boolean>;
  commands: Record<string, CommandState>;
}
```

**Step 2: Write the failing test**

```typescript
// src/core/StateManager.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm } from 'fs/promises';
import { join } from 'path';
import { StateManager } from './StateManager.js';

describe('StateManager', () => {
  const stateDir = join(process.cwd(), '.test-state');
  let manager: StateManager;

  beforeEach(async () => {
    await mkdir(stateDir, { recursive: true });
    manager = new StateManager(stateDir);
  });

  afterEach(async () => {
    await rm(stateDir, { recursive: true, force: true });
  });

  it('should create new instance state', async () => {
    const state = await manager.createInstance('brainstorm', 'my-topic', {
      topic: 'my-topic',
      outputDir: 'specs/my-topic'
    });

    expect(state.instance).toBe('my-topic');
    expect(state.workflow).toBe('brainstorm');
    expect(state.variables.topic).toBe('my-topic');
    expect(state.createdAt).toBeDefined();
  });

  it('should load existing instance state', async () => {
    await manager.createInstance('brainstorm', 'my-topic', { topic: 'my-topic' });
    const state = await manager.loadInstance('brainstorm', 'my-topic');

    expect(state?.instance).toBe('my-topic');
  });

  it('should return null for non-existent instance', async () => {
    const state = await manager.loadInstance('brainstorm', 'nonexistent');
    expect(state).toBeNull();
  });

  it('should update command status', async () => {
    await manager.createInstance('brainstorm', 'my-topic', { topic: 'my-topic' });

    await manager.updateCommandStatus('brainstorm', 'my-topic', 'init', 'completed', {
      output: 'specs/my-topic/init.md'
    });

    const state = await manager.loadInstance('brainstorm', 'my-topic');
    expect(state?.commands.init.status).toBe('completed');
    expect(state?.commands.init.output).toBe('specs/my-topic/init.md');
    expect(state?.commands.init.completedAt).toBeDefined();
  });

  it('should invalidate dependent commands', async () => {
    await manager.createInstance('brainstorm', 'my-topic', { topic: 'my-topic' });

    // Mark init as completed
    await manager.updateCommandStatus('brainstorm', 'my-topic', 'init', 'completed');
    await manager.updateCommandStatus('brainstorm', 'my-topic', 'next', 'completed');

    // Invalidate next
    await manager.invalidateDependents('brainstorm', 'my-topic', 'init', ['next']);

    const state = await manager.loadInstance('brainstorm', 'my-topic');
    expect(state?.commands.next.status).toBe('needs-update');
    expect(state?.commands.next.invalidatedBy).toBe('init');
  });
});
```

**Step 3: Run test to verify it fails**

Run: `npm test -- src/core/StateManager.test.ts`
Expected: FAIL - StateManager not defined

**Step 4: Write minimal implementation**

```typescript
// src/core/StateManager.ts
import { mkdir, readFile, writeFile, access } from 'fs/promises';
import { join } from 'path';
import type { WorkflowInstanceState, CommandStatus, CommandState } from '../types/state.js';

export class StateManager {
  private stateDir: string;

  constructor(stateDir: string) {
    this.stateDir = stateDir;
  }

  private getStatePath(workflow: string, instance: string): string {
    return join(this.stateDir, workflow, `${instance}.yaml`);
  }

  async createInstance(
    workflow: string,
    instance: string,
    variables: Record<string, string | number | boolean>
  ): Promise<WorkflowInstanceState> {
    const now = new Date().toISOString();
    const state: WorkflowInstanceState = {
      instance,
      workflow,
      createdAt: now,
      updatedAt: now,
      variables,
      commands: {}
    };

    const statePath = this.getStatePath(workflow, instance);
    await mkdir(join(this.stateDir, workflow), { recursive: true });
    await this.saveState(statePath, state);

    return state;
  }

  async loadInstance(workflow: string, instance: string): Promise<WorkflowInstanceState | null> {
    const statePath = this.getStatePath(workflow, instance);

    try {
      await access(statePath);
    } catch {
      return null;
    }

    const content = await readFile(statePath, 'utf-8');
    const { parse } = await import('yaml');
    return parse(content) as WorkflowInstanceState;
  }

  async updateCommandStatus(
    workflow: string,
    instance: string,
    command: string,
    status: CommandStatus,
    extra?: Partial<CommandState>
  ): Promise<void> {
    const state = await this.loadInstance(workflow, instance);
    if (!state) {
      throw new Error(`Instance ${instance} not found`);
    }

    const now = new Date().toISOString();
    state.commands[command] = {
      ...state.commands[command],
      status,
      ...extra
    };

    if (status === 'in_progress' && !state.commands[command].startedAt) {
      state.commands[command].startedAt = now;
    }

    if (status === 'completed') {
      state.commands[command].completedAt = now;
    }

    state.updatedAt = now;
    await this.saveState(this.getStatePath(workflow, instance), state);
  }

  async invalidateDependents(
    workflow: string,
    instance: string,
    sourceCommand: string,
    dependents: string[]
  ): Promise<void> {
    const state = await this.loadInstance(workflow, instance);
    if (!state) return;

    const now = new Date().toISOString();

    for (const dep of dependents) {
      if (state.commands[dep] && state.commands[dep].status === 'completed') {
        state.commands[dep] = {
          ...state.commands[dep],
          previousStatus: state.commands[dep].status,
          status: 'needs-update',
          invalidatedBy: sourceCommand,
          invalidatedAt: now
        };
      }
    }

    state.updatedAt = now;
    await this.saveState(this.getStatePath(workflow, instance), state);
  }

  private async saveState(path: string, state: WorkflowInstanceState): Promise<void> {
    const { stringify } = await import('yaml');
    await writeFile(path, stringify(state), 'utf-8');
  }
}
```

**Step 5: Run test to verify it passes**

Run: `npm test -- src/core/StateManager.test.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add src/core/StateManager.ts src/core/StateManager.test.ts src/types/state.ts
git commit -m "feat: add StateManager for workflow instance state tracking

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>"
```

---

## Task 6: craft init Command

**Files:**
- Create: `src/commands/init.ts`
- Create: `src/commands/init.test.ts`

**Step 1: Write the failing test**

```typescript
// src/commands/init.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, readFile, access } from 'fs/promises';
import { join } from 'path';
import { initCommand } from './init.js';

describe('init command', () => {
  const testDir = join(process.cwd(), '.test-init');

  beforeEach(async () => {
    await mkdir(testDir, { recursive: true });
  });

  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
  });

  it('should create marketplace directory with config files', async () => {
    const marketplacePath = join(testDir, 'my-workflows');

    await initCommand(marketplacePath);

    // Check marketplace.json exists
    await expect(access(join(marketplacePath, 'marketplace.json'))).resolves.toBeUndefined();

    // Check README.md exists
    await expect(access(join(marketplacePath, 'README.md'))).resolves.toBeUndefined();
  });

  it('should create valid marketplace.json', async () => {
    const marketplacePath = join(testDir, 'my-workflows');

    await initCommand(marketplacePath);

    const content = await readFile(join(marketplacePath, 'marketplace.json'), 'utf-8');
    const config = JSON.parse(content);

    expect(config.name).toBe('my-workflows');
    expect(config.version).toBe('1.0.0');
    expect(config.workflows).toEqual([]);
  });

  it('should initialize in current directory when path is "."', async () => {
    await initCommand(testDir);

    await expect(access(join(testDir, 'marketplace.json'))).resolves.toBeUndefined();
  });

  it('should throw error if directory already has marketplace.json', async () => {
    const marketplacePath = join(testDir, 'existing');
    await mkdir(marketplacePath);

    // Create existing marketplace.json
    await import('fs/promises').then(fs =>
      fs.writeFile(join(marketplacePath, 'marketplace.json'), '{}')
    );

    await expect(initCommand(marketplacePath)).rejects.toThrow('already exists');
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test -- src/commands/init.test.ts`
Expected: FAIL - initCommand not defined

**Step 3: Write minimal implementation**

```typescript
// src/commands/init.ts
import { mkdir, writeFile, access } from 'fs/promises';
import { join, basename } from 'path';
import { Command } from 'commander';

export const initCommand = new Command('init')
  .description('Create a new marketplace')
  .argument('<name>', 'Marketplace name or "." for current directory')
  .action(async (name: string) => {
    await initCommandHandler(name);
  });

export async function initCommandHandler(name: string): Promise<void> {
  const targetDir = name === '.' ? process.cwd() : join(process.cwd(), name);
  const marketplaceName = name === '.' ? basename(process.cwd()) : name;

  // Check if already initialized
  const configPath = join(targetDir, 'marketplace.json');
  try {
    await access(configPath);
    throw new Error(`marketplace.json already exists in ${targetDir}`);
  } catch (err: unknown) {
    if ((err as Error).message.includes('already exists')) {
      throw err;
    }
    // File doesn't exist, continue
  }

  // Create directory
  await mkdir(targetDir, { recursive: true });

  // Create marketplace.json
  const marketplaceConfig = {
    name: marketplaceName,
    version: '1.0.0',
    description: `${marketplaceName} spec workflows`,
    workflows: []
  };

  await writeFile(
    join(targetDir, 'marketplace.json'),
    JSON.stringify(marketplaceConfig, null, 2),
    'utf-8'
  );

  // Create README.md
  const readme = `# ${marketplaceName}

Spec workflows marketplace.

## Usage

\`\`\`bash
# Copy a workflow from template
craft copy brainstorm

# Run a workflow
craft run brainstorm init my-topic
\`\`\`

## Workflows

<!-- Add your workflows here -->
`;

  await writeFile(join(targetDir, 'README.md'), readme, 'utf-8');

  console.log(`✅ Created marketplace at ${targetDir}`);
}

export { initCommandHandler as initCommand };
```

**Step 4: Run test to verify it passes**

Run: `npm test -- src/commands/init.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/commands/init.ts src/commands/init.test.ts
git commit -m "feat: add craft init command for creating marketplaces

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>"
```

---

## Task 7: craft copy Command

**Files:**
- Create: `src/commands/copy.ts`
- Create: `src/commands/copy.test.ts`
- Create: `templates/brainstorm/SKILL.md`
- Create: `templates/brainstorm/workflow.yaml`
- Create: `templates/brainstorm/templates/brainstorm.md`

**Step 1: Write the failing test**

```typescript
// src/commands/copy.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, access, readFile } from 'fs/promises';
import { join } from 'path';
import { copyCommand } from './copy.js';

describe('copy command', () => {
  const testDir = join(process.cwd(), '.test-copy');
  const templateDir = join(process.cwd(), 'templates');

  beforeEach(async () => {
    await mkdir(testDir, { recursive: true });
  });

  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
  });

  it('should copy workflow from template library', async () => {
    await copyCommand('brainstorm', testDir);

    // Check files exist
    await expect(access(join(testDir, 'brainstorm', 'SKILL.md'))).resolves.toBeUndefined();
    await expect(access(join(testDir, 'brainstorm', 'workflow.yaml'))).resolves.toBeUndefined();
    await expect(access(join(testDir, 'brainstorm', 'templates', 'brainstorm.md'))).resolves.toBeUndefined();
  });

  it('should throw error if template not found', async () => {
    await expect(copyCommand('nonexistent', testDir)).rejects.toThrow('not found');
  });

  it('should throw error if workflow already exists', async () => {
    await mkdir(join(testDir, 'brainstorm'), { recursive: true });

    await expect(copyCommand('brainstorm', testDir)).rejects.toThrow('already exists');
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test -- src/commands/copy.test.ts`
Expected: FAIL - copyCommand not defined

**Step 3: Create template files**

```yaml
# templates/brainstorm/workflow.yaml
name: brainstorm
version: 1.0.0
description: 通过问答式交互，将模糊想法转化为清晰设计

variables:
  topic:
    type: string
    required: true
    description: 要探索的主题
    prompt: 请输入要探索的主题
  outputDir:
    type: string
    default: "specs/{{topic}}"

commands:
  init:
    description: 初始化 brainstorm
    template: templates/brainstorm.md
    output: "{{outputDir}}/brainstorm.md"

  next:
    description: 继续下一个问题

  status:
    description: 查看当前状态

  validate:
    description: 验证 brainstorm 是否完整

  done:
    description: 完成 brainstorm
    template: templates/summary.md
    output: "{{outputDir}}/summary.md"
```

```markdown
# templates/brainstorm/SKILL.md
# Brainstorm 工作流

通过问答式交互，将模糊想法转化为清晰的设计文档。

## 何时使用

- 有一个模糊的想法，需要探索和细化
- 需要做技术决策，想系统性地分析
- 开始一个新功能前，想先理清思路

## 使用方式

使用 `craft run brainstorm <command>` 执行命令：

### 初始化

\`\`\`bash
craft run brainstorm init <topic>
\`\`\`

创建一个新的 brainstorm 文档，开始探索。

### 继续探索

\`\`\`bash
craft run brainstorm next
\`\`\`

Agent 会提出下一个问题来深化思考。

### 查看状态

\`\`\`bash
craft run brainstorm status
\`\`\`

查看当前探索的进度和已覆盖的维度。

### 验证

\`\`\`bash
craft run brainstorm validate
\`\`\`

检查 brainstorm 是否完整，是否可以进入下一阶段。

### 完成

\`\`\`bash
craft run brainstorm done
\`\`\`

生成最终的设计摘要。

## 流程建议

1. 先运行 `init` 开始
2. 多次运行 `next` 深入探索
3. 随时用 `status` 查看进度
4. 用 `validate` 检查完整性
5. 最后用 `done` 完成

## 产出

- `specs/<topic>/brainstorm.md` — 探索过程记录
- `specs/<topic>/summary.md` — 最终设计摘要
```

```markdown
# templates/brainstorm/templates/brainstorm.md
# Brainstorm: {{topic}}

> 创建时间: {{createdAt}}

---

## 探索目标

<!-- 描述你想探索的主题 -->

## 背景与动机

<!-- 为什么这个主题重要？ -->

## 核心问题

<!-- 想要回答的关键问题 -->

## 探索笔记

<!-- 记录探索过程中的思考和发现 -->

## 待探索维度

- [ ] 用户需求
- [ ] 技术可行性
- [ ] 边界情况
- [ ] 风险与挑战

## 下一步

<!-- 记录下一步想要探索的方向 -->
```

**Step 4: Write minimal implementation**

```typescript
// src/commands/copy.ts
import { mkdir, access, cp } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { Command } from 'commander';

const __dirname = dirname(fileURLToPath(import.meta.url));

export const copyCommand = new Command('copy')
  .description('Copy a workflow from template library')
  .argument('<template>', 'Template name')
  .option('-d, --directory <dir>', 'Target directory', '.')
  .action(async (template: string, options: { directory: string }) => {
    await copyCommandHandler(template, options.directory);
  });

export async function copyCommandHandler(template: string, targetDir: string): Promise<void> {
  // Template directory (relative to this file)
  const templatePath = join(__dirname, '..', '..', 'templates', template);
  const targetPath = join(targetDir, template);

  // Check if template exists
  try {
    await access(templatePath);
  } catch {
    throw new Error(`Template "${template}" not found`);
  }

  // Check if target already exists
  try {
    await access(targetPath);
    throw new Error(`Workflow "${template}" already exists in ${targetDir}`);
  } catch (err: unknown) {
    if ((err as Error).message.includes('already exists')) {
      throw err;
    }
    // Doesn't exist, continue
  }

  // Copy template
  await mkdir(join(targetDir, template), { recursive: true });
  await cp(templatePath, targetPath, { recursive: true });

  console.log(`✅ Copied workflow "${template}" to ${targetPath}`);
}
```

**Step 5: Run test to verify it passes**

Run: `npm test -- src/commands/copy.test.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add src/commands/copy.ts src/commands/copy.test.ts templates/brainstorm/
git commit -m "feat: add craft copy command and brainstorm template

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>"
```

---

## Task 8: craft run Command (Basic)

**Files:**
- Create: `src/commands/run.ts`
- Create: `src/commands/run.test.ts`
- Create: `src/core/CommandExecutor.ts`

**Step 1: Write the failing test**

```typescript
// src/commands/run.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, writeFile, access, readFile } from 'fs/promises';
import { join } from 'path';
import { runCommandHandler } from './run.js';

describe('run command', () => {
  const testDir = join(process.cwd(), '.test-run');
  const stateDir = join(testDir, '.craft', 'state');

  beforeEach(async () => {
    await mkdir(testDir, { recursive: true });
  });

  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
  });

  it('should run template command and generate output', async () => {
    // Setup workflow
    const workflowDir = join(testDir, 'test-workflow');
    await mkdir(join(workflowDir, 'templates'), { recursive: true });

    const workflowYaml = `
name: test-workflow
version: 1.0.0
variables:
  topic:
    type: string
    required: true
commands:
  init:
    description: Initialize
    template: templates/init.md
    output: "specs/{{topic}}/init.md"
`;

    await writeFile(join(workflowDir, 'workflow.yaml'), workflowYaml);
    await writeFile(join(workflowDir, 'templates', 'init.md'), '# {{topic}}\n\nCreated at: {{createdAt}}');

    // Run command
    await runCommandHandler({
      workflowPath: workflowDir,
      command: 'init',
      variables: { topic: 'my-topic', createdAt: new Date().toISOString() },
      stateDir
    });

    // Check output
    const outputPath = join(testDir, 'specs', 'my-topic', 'init.md');
    await expect(access(outputPath)).resolves.toBeUndefined();

    const content = await readFile(outputPath, 'utf-8');
    expect(content).toContain('# my-topic');
  });

  it('should throw error for unknown command', async () => {
    const workflowDir = join(testDir, 'test-workflow');
    await mkdir(workflowDir);

    const workflowYaml = `
name: test-workflow
version: 1.0.0
commands:
  init:
    description: Initialize
`;

    await writeFile(join(workflowDir, 'workflow.yaml'), workflowYaml);

    await expect(runCommandHandler({
      workflowPath: workflowDir,
      command: 'unknown',
      variables: {},
      stateDir
    })).rejects.toThrow('not found');
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test -- src/commands/run.test.ts`
Expected: FAIL - runCommandHandler not defined

**Step 3: Create CommandExecutor**

```typescript
// src/core/CommandExecutor.ts
import { mkdir, writeFile } from 'fs/promises';
import { dirname, join } from 'path';
import type { WorkflowDefinition, WorkflowCommand } from '../types/workflow.js';
import { TemplateRenderer, type TemplateVariables } from './TemplateRenderer.js';
import { StateManager } from './StateManager.js';

export interface ExecuteOptions {
  workflowPath: string;
  definition: WorkflowDefinition;
  command: string;
  variables: TemplateVariables;
  stateDir: string;
  force?: boolean;
}

export class CommandExecutor {
  private renderer: TemplateRenderer;
  private stateManager: StateManager;

  constructor(stateDir: string) {
    this.renderer = new TemplateRenderer();
    this.stateManager = new StateManager(stateDir);
  }

  async execute(options: ExecuteOptions): Promise<{ output?: string }> {
    const { workflowPath, definition, command, variables, force } = options;
    const workflowName = definition.name;
    const instanceName = String(variables.topic || variables.feature || 'default');

    // Get command definition
    const cmdDef = definition.commands[command];
    if (!cmdDef) {
      throw new Error(`Command "${command}" not found in workflow "${workflowName}"`);
    }

    // Create or load state
    let state = await this.stateManager.loadInstance(workflowName, instanceName);
    if (!state) {
      state = await this.stateManager.createInstance(workflowName, instanceName, variables);
    }

    // Check if already completed
    const cmdState = state.commands[command];
    if (cmdState?.status === 'completed' && !force) {
      console.log(`Command "${command}" already completed. Use --force to re-run.`);
      return { output: cmdState.output };
    }

    // Update status to in_progress
    await this.stateManager.updateCommandStatus(workflowName, instanceName, command, 'in_progress');

    try {
      let outputPath: string | undefined;

      // Handle different command types
      if (cmdDef.template && cmdDef.output) {
        // Template command
        const templatePath = join(workflowPath, cmdDef.template);
        const renderedOutput = await this.renderer.render(templatePath, {
          ...variables,
          createdAt: new Date().toISOString()
        });

        // Resolve output path
        outputPath = this.renderer.renderString(cmdDef.output, variables);
        const fullOutputPath = join(process.cwd(), outputPath);

        // Ensure directory exists
        await mkdir(dirname(fullOutputPath), { recursive: true });

        // Write output
        await writeFile(fullOutputPath, renderedOutput, 'utf-8');
        console.log(`✅ Generated: ${outputPath}`);
      }

      // Mark as completed
      await this.stateManager.updateCommandStatus(workflowName, instanceName, command, 'completed', {
        output: outputPath
      });

      return { output: outputPath };
    } catch (error) {
      await this.stateManager.updateCommandStatus(workflowName, instanceName, command, 'failed');
      throw error;
    }
  }
}
```

**Step 4: Write run command**

```typescript
// src/commands/run.ts
import { Command } from 'commander';
import { WorkflowLoader } from '../core/WorkflowLoader.js';
import { CommandExecutor } from '../core/CommandExecutor.js';
import { join } from 'path';

export interface RunOptions {
  workflowPath: string;
  command: string;
  variables: Record<string, string | number | boolean>;
  stateDir: string;
  force?: boolean;
}

export const runCommand = new Command('run')
  .description('Run a workflow command')
  .argument('<workflow>', 'Workflow name')
  .argument('<command>', 'Command to run')
  .argument('[args...]', 'Command arguments')
  .option('-f, --force', 'Force re-execution')
  .option('--no-auto', 'Skip automatic dependency execution')
  .option('--state-dir <dir>', 'State directory', '.craft/state')
  .action(async (workflow: string, command: string, args: string[], options: {
    force?: boolean;
    auto: boolean;
    stateDir: string;
  }) => {
    // Find workflow in current directory or marketplace
    const workflowPath = join(process.cwd(), workflow);

    await runCommandHandler({
      workflowPath,
      command,
      variables: { topic: args[0] || 'default' },
      stateDir: options.stateDir,
      force: options.force
    });
  });

export async function runCommandHandler(options: RunOptions): Promise<{ output?: string }> {
  const { workflowPath, command, variables, stateDir, force } = options;

  // Load workflow
  const loader = new WorkflowLoader();
  const workflow = await loader.load(workflowPath);

  // Execute command
  const executor = new CommandExecutor(stateDir);
  return executor.execute({
    workflowPath,
    definition: workflow.definition,
    command,
    variables,
    stateDir,
    force
  });
}
```

**Step 5: Run test to verify it passes**

Run: `npm test -- src/commands/run.test.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add src/commands/run.ts src/commands/run.test.ts src/core/CommandExecutor.ts
git commit -m "feat: add craft run command with template execution

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>"
```

---

## Task 9: Build and Integration Test

**Files:**
- Create: `tests/integration/basic.test.ts`

**Step 1: Write integration test**

```typescript
// tests/integration/basic.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, access, readFile } from 'fs/promises';
import { join } from 'path';
import { execSync } from 'child_process';
import { initCommandHandler } from '../../src/commands/init.js';
import { copyCommandHandler } from '../../src/commands/copy.js';
import { runCommandHandler } from '../../src/commands/run.js';

describe('Integration: Basic Workflow', () => {
  const testDir = join(process.cwd(), '.test-integration');

  beforeEach(async () => {
    await mkdir(testDir, { recursive: true });
  });

  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
  });

  it('should complete full workflow: init -> copy -> run', async () => {
    // 1. Create marketplace
    await initCommandHandler(testDir);

    // 2. Copy brainstorm workflow
    await copyCommandHandler('brainstorm', testDir);

    // 3. Run brainstorm init
    const workflowPath = join(testDir, 'brainstorm');
    const stateDir = join(testDir, '.craft', 'state');

    await runCommandHandler({
      workflowPath,
      command: 'init',
      variables: { topic: 'my-feature' },
      stateDir
    });

    // 4. Verify output
    const outputPath = join(testDir, 'specs', 'my-feature', 'brainstorm.md');
    await expect(access(outputPath)).resolves.toBeUndefined();

    const content = await readFile(outputPath, 'utf-8');
    expect(content).toContain('Brainstorm: my-feature');
  });

  it('should track command state', async () => {
    await initCommandHandler(testDir);
    await copyCommandHandler('brainstorm', testDir);

    const workflowPath = join(testDir, 'brainstorm');
    const stateDir = join(testDir, '.craft', 'state');

    await runCommandHandler({
      workflowPath,
      command: 'init',
      variables: { topic: 'state-test' },
      stateDir
    });

    // Check state file
    const statePath = join(stateDir, 'brainstorm', 'state-test.yaml');
    await expect(access(statePath)).resolves.toBeUndefined();

    const stateContent = await readFile(statePath, 'utf-8');
    expect(stateContent).toContain('completed');
    expect(stateContent).toContain('init:');
  });
});
```

**Step 2: Run integration test**

Run: `npm test -- tests/integration/basic.test.ts`
Expected: PASS

**Step 3: Build the project**

Run: `npm run build`
Expected: Build succeeds with no errors

**Step 4: Commit**

```bash
git add tests/integration/basic.test.ts
git commit -m "test: add integration test for basic workflow

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>"
```

---

## Task 10: Update README and Finalize

**Files:**
- Modify: `README.md`

**Step 1: Update README**

```markdown
# SpecCraft

Spec Creator - CLI tool for spec-driven workflows.

## Installation

```bash
npm install -g @speccraft/cli
```

## Quick Start

### 1. Create a Marketplace

```bash
craft init my-team-workflows
cd my-team-workflows
```

### 2. Copy Built-in Templates

```bash
craft copy brainstorm
```

### 3. Run Workflow Commands

```bash
craft run brainstorm init my-topic
```

## Commands

### craft init

Create a new marketplace.

```bash
craft init <name>
craft init .  # Initialize in current directory
```

### craft copy

Copy a workflow from the template library.

```bash
craft copy brainstorm
craft copy feature-dev
```

### craft run

Run a workflow command.

```bash
craft run <workflow> <command> [args...]
craft run brainstorm init my-topic
craft run brainstorm next
craft run brainstorm status
```

Options:
- `-f, --force` - Force re-execution
- `--no-auto` - Skip automatic dependency execution

## Built-in Templates

### brainstorm

Interactive workflow to transform vague ideas into clear design documents.

Commands: `init`, `next`, `status`, `validate`, `done`

## Development

```bash
npm install
npm run build
npm test
```

## License

MIT
```

**Step 2: Run all tests**

Run: `npm test`
Expected: All tests pass

**Step 3: Type check**

Run: `npm run typecheck`
Expected: No errors

**Step 4: Final commit**

```bash
git add README.md
git commit -m "docs: update README with usage instructions

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>"
```

---

## Summary

Phase 1 delivers a working MVP with:

1. **Project Setup** - TypeScript, vitest, dependencies
2. **CLI Entry Point** - Commander.js-based command parsing
3. **Workflow Loader** - Parse and validate workflow.yaml
4. **Template Renderer** - Mustache-based template rendering
5. **State Manager** - Track workflow instance state
6. **craft init** - Create marketplaces
7. **craft copy** - Copy from template library
8. **craft run** - Execute workflow commands
9. **Integration Tests** - End-to-end verification
10. **Documentation** - README with usage examples

**Next Phase:** Command types (execution, query, interactive), dependency resolution, state invalidation.
